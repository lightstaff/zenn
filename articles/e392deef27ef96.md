---
title: "Akka gRPCï¼ˆScalaï¼‰+CloudTraceã§åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°"
emoji: "ğŸ’¾"
type: "tech"
topics: ["scala", "grpc", "akka", "opentelemetry", "cloudtrace"]
published: true
---

# ã¯ã˜ã‚ã«
## CloudTraceã¨ã¯
æ¦‚è¦ã¯[ã“ã¡ã‚‰](https://cloud.google.com/trace)ã€‚

GCPæ›°ãã€Œèª°ã§ã‚‚ä½¿ç”¨ã§ãã‚‹åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚¹ ã‚·ã‚¹ãƒ†ãƒ ã€ã¨ã®ã“ã¨ã§ã€GKEä¸Šã§å‹•ã‹ã—ã¦ã„ã‚‹**Akka gRPC**ã§æ›¸ã‹ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹ã®ãƒˆãƒ¬ãƒ¼ã‚¹çµæœã‚’ä¸‹ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ï¼ˆ[ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆã‚ˆã‚Šæ‹å€Ÿ](https://cloud.google.com/trace/docs/quickstart#view_the_trace_overview)ï¼‰ã®ã‚ˆã†ã«è¦‹ãŸã„ãªãã¨ã„ã†ã®ãŒä»Šå›ã®å‹•æ©Ÿã€‚
![ãƒˆãƒ¬ãƒ¼ã‚¹ç”»é¢](https://cloud.google.com/trace/images/quickstart-waterfall-example.png)

Scalaç’°å¢ƒã§ã¯OpenTelemetryï¼ˆJavaï¼‰ã‚’åˆ©ç”¨ã§ããã†ã§ã™ã€‚

## OpenTelemetryã¨ã¯
æ¦‚è¦ã¯[ã“ã¡ã‚‰](https://opentelemetry.io/)ã€‚

Googleç¿»è¨³ã«ã‚ˆã‚‹ã¨ã€ŒOpenTelemetryã¯ã€ãƒˆãƒ¬ãƒ¼ã‚¹ã€ãƒ¡ãƒˆãƒªãƒƒã‚¯ã€ãƒ­ã‚°ãªã©ã®ãƒ†ãƒ¬ãƒ¡ãƒˆãƒªãƒ‡ãƒ¼ã‚¿ã®ä½œæˆã¨ç®¡ç†ç”¨ã«è¨­è¨ˆã•ã‚ŒãŸã€APIã€SDKã€ãƒ„ãƒ¼ãƒ«ã€ãŠã‚ˆã³çµ±åˆã®ã‚»ãƒƒãƒˆã§ã™ã€‚ã€ã‚‰ã—ã„ã€‚

OpenTracingã¨OpenCensusã®åˆä½µã—ãŸå¾Œç¶™ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€CNCFã®ã‚¤ãƒ³ã‚­ãƒ¥ãƒ™ãƒ¼ã‚¿ãƒ¼ã«ãªã£ã¦ã„ã¾ã™ã€‚

Javaä»¥å¤–ã«ã‚‚Goã¨ã‹.Netã¨ã‹ç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã¿ãŸã„ã§ã™ã­ã€‚

# Akka gRPCã§åˆ©ç”¨ã™ã‚‹
## åˆ†æ•£ã—ãªã„ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°
æ—©é€ŸGCPã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€Œ[Java ã¨ OpenTelemetry](https://cloud.google.com/trace/docs/setup/java-ot)ã€è¾ºã‚Šã‚’å‚è€ƒã«å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚

ã‚ã£ã¡ã‚ƒç°¡å˜ã˜ã‚ƒã‚“ã€‚

ã¨æ€ã„ãã‚„å…¨ç„¶åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã«ãªã£ã¦ãŠã‚‰ãšã€å€‹ã€…ã®ãƒˆãƒ¬ãƒ¼ã‚¹çµæœãŒåˆ¥ã€…ã«è¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹ã ã‘ã®å¯‚ã—ã„ã‚‚ã®ã«ãƒ»ãƒ»ãƒ»ã€‚

## ãƒªãƒ¢ãƒ¼ãƒˆé–“ã§ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¼æ¬ã›ã‚ˆ
ä»•æ–¹ãªã„ã®ã§OpenTelemetryå´ã®[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://opentelemetry.io/docs/java/manual_instrumentation/)ã‚’è¦‹ã¦ã¿ã‚‹ã¨ã©ã†ã‚„ã‚‰TraceIDã‚„ã‚‰SpanIDã‚„ã‚‰ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚­ãƒ£ãƒªã‚¢ï¼ˆHttpã‚’åˆ©ç”¨ã—ãŸã‚µãƒ¼ãƒ“ã‚¹ã ã£ãŸã‚‰Httpãƒ˜ãƒƒãƒ€ã¨ã‹ï¼‰ã«åŸ‹ã‚è¾¼ã‚“ã§ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä¼æ¬ï¼‰ã—ã‚ã¨ãƒ»ãƒ»ãƒ»ã€‚

ã¾ãå½“ãŸã‚Šå‰ã‹ã€‚

ã§ã‚‚è¦ªåˆ‡ãªã“ã¨ã«[W3Cæº–æ‹ ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ](https://www.w3.org/TR/trace-context/)ã®ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚¿ãƒ¼ï¼ˆä¼æ¬å±‹ï¼‰ã¨å‘¼ã°ã‚Œã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‘ãƒ¼ã‚µãƒ¼ãŒæ¨™æº–ã§ç”¨æ„ã—ã¦ã‚ã‚‹ã®ã§ãã‚Œã‚’ä½¿ãˆã°è‰¯ã„ã¨æ›¸ã„ã¦ã‚ã‚Šã¾ã™ã­ã€‚

## Javaã®gRPCã ã£ãŸã‚‰ãƒ»ãƒ»ãƒ»
gRPCã§ã¯Httpãƒ˜ãƒƒãƒ€ã®ã‚ˆã†ã«å¤–éƒ¨ãƒ‡ãƒ¼ã‚¿ã‚’åŸ‹ã‚è¾¼ã¿ãŸã„å ´åˆã¯ã€[Metadata](https://grpc.io/docs/what-is-grpc/core-concepts/#metadata)ã‚’åˆ©ç”¨ã™ã‚Œã°è‰¯ã•ãã†ã§ã™ã€‚

ã“ã‚Œã¾ãŸè¦ªåˆ‡ãªã“ã¨ã«[githubã®examples/grpc](https://github.com/open-telemetry/opentelemetry-java/tree/main/examples/grpc)ã«Interceptorã‚’åˆ©ç”¨ã—ãŸå®Ÿè£…ä¾‹ãŒè¼‰ã£ã¦ã„ã¾ã™ã€‚

Javaã®æ¨™æº–gRPCã ã£ãŸã‚‰è‹¦ã‚‚ç„¡ãå®Ÿè£…ã§ããã†ã§ã™ã­ãƒ»ãƒ»ãƒ»ã€‚

## Akka gRPCæ•…ã«
å‰æã¨ã—ã¦ã€Akka gRPCã®Metadataã¸ã®ãƒ‡ãƒ¼ã‚¿åŸ‹ã‚è¾¼ã¿æ–¹æ³•ã¯ã€`SingleResponseRequestBuilder`ï¼ˆã‚‚ã—ãã¯`StreamResponseRequestBuilder`ï¼‰ã®`addHeader(key: String, value: String)`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã“ã¨ã§Metadataã®åŸ‹ã‚è¾¼ã¾ã‚ŒãŸ`SingleResponseRequestBuilder`ãŒ**è¿”ã£ã¦ãã¾ã™**ï¼ˆ[å‚è€ƒ](https://doc.akka.io/docs/akka-grpc/current/client/details.html)ï¼‰ã€‚

ãã—ã¦OpenTelemetryã«æ¨™æº–ã§ç”¨æ„ã•ã‚Œã¦ã„ã‚‹`TextMapPropergetor`ã¯`TextMapSetter<T>`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å—ã‘å–ã‚‹`inject`ãƒ¡ã‚½ãƒƒãƒ‰ã¨ã€`TextMapGetter<T>`ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å—ã‘å–ã‚‹`extract`ãƒ¡ã‚½ãƒƒãƒ‰ã«ã‚ˆã‚Šæ–‡å­—åˆ—â†â†’ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ãƒ‘ãƒ¼ã‚¹å‡¦ç†ã‚’è¡Œã„ã¾ã™ï¼ˆTå‹ã¯ã‚­ãƒ£ãƒªã‚¢ã®å‹ï¼‰ã€‚

`TextMapSetter<T>`ã§å®Ÿè£…ã‚’å¿…è¦ã¨ã™ã‚‹`set(carrier: T, key: String, value: String)`ãƒ¡ã‚½ãƒƒãƒ‰ã®æˆ»ã‚Šå€¤ã¯`Unit`ã§ã‚ã‚Šã€æ›´æ–°ã•ã‚ŒãŸ`T`ã¯**è¿”ã£ã¦ãã¾ã›ã‚“**ã€‚

Akka gRPCã®å ´åˆã€`TextMapSetter<T>`ã®Tå‹ã¯`SingleResponseRequestBuilder`ã«ãªã‚‹ã‚ã‘ãªã‚“ã§ã™ãŒãƒ»ãƒ»ãƒ»ã€‚

ã‚·ã‚°ãƒãƒãƒ£ãŒå™›ã¿åˆã„ã¾ã›ã‚“ã€‚`ResponseRequestBuilder`ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’ç”¨æ„ã—ã¦ã‚´ãƒ‹ãƒ§ã‚´ãƒ‹ãƒ§ã™ã‚‹ã“ã¨ã‚‚ã§ããã†ã§ã™ãŒã€å‰¯ä½œç”¨ãã•ããªã‚‹ã®ã¯è¨±å®¹ã§ãã¾ã›ã‚“ã€‚

ã‚ã€ã‚ã¨Interceptorã‚‚ç„¡ã„ã§ã™ï¼ˆ[ã‚³ãƒ³ã‚»ãƒ—ãƒˆãŒé•ã†ã‹ã‚‰ç”¨æ„ã™ã‚‹æ°—ãªã„ã‚ˆã¨è¨€ã£ã¦ãŠã‚‰ã‚Œã‚‹](https://discuss.lightbend.com/t/adds-grpc-interceptor/3236)ï¼‰ã€‚ãƒ¡ã‚½ãƒƒãƒ‰æ¯ã«ãƒˆãƒ¬ãƒ¼ã‚µãƒ¼ã®åŸ‹ã‚è¾¼ã¿ãƒ»å–ã‚Šå‡ºã—å‡¦ç†ãŒå¿…è¦ã§ã™ã€‚â†ã“ã‚ŒãŒåœ°å‘³ã«ã—ã‚“ã©ã‹ã£ãŸã€‚

## ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚¿ãƒ¼ã‚’å®Ÿè£…ã™ã‚‹
ã—ã‚ˆã†ãŒãªã„ã§Akka gRPCç”¨ã«ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚¿ãƒ¼ã‚’è‡ªåŠ›ã§å®Ÿè£…ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

ã¨ã‚Šã‚ãˆãšã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¯W3Cæº–æ‹ ã§[ã“ã“ã‚‰è¾º](https://github.com/open-telemetry/opentelemetry-java/blob/main/api/all/src/main/java/io/opentelemetry/api/trace/propagation/W3CTraceContextPropagator.java)ã‚’å‚è€ƒã«å®Ÿè£…ã—ã¾ã™ã€‚

::: details é•·ã„ã®ã§ç•³ã¿ã¾ã™
```scala
package com.example

import java.util.regex.Pattern

import scala.jdk.CollectionConverters.*
import scala.util.Failure
import scala.util.Success
import scala.util.Try

import cats.implicits.*
import io.opentelemetry.api.internal.OtelEncodingUtils
import io.opentelemetry.api.internal.TemporaryBuffers
import io.opentelemetry.api.internal.Utils.checkArgument
import io.opentelemetry.api.trace.*
import io.opentelemetry.context.Context
import net.logstash.logback.argument.StructuredArguments.keyValue

/** W3C Trace context propergator */
object W3CTraceContextPropergator {

  private val TRACE_PARENT = "traceparent"

  private val TRACE_STATE = "tracestate"

  private val VERSION = "00"

  private val VERSION_SIZE = 2

  private val TRACEPARENT_DELIMITER = '-'

  private val TRACEPARENT_DELIMITER_SIZE = 1

  private val TRACE_ID_HEX_SIZE = TraceId.getLength

  private val SPAN_ID_HEX_SIZE = SpanId.getLength

  private val TRACE_OPTION_HEX_SIZE = TraceFlags.getLength

  private val TRACE_ID_OFFSET = VERSION_SIZE + TRACEPARENT_DELIMITER_SIZE

  private val SPAN_ID_OFFSET =
    TRACE_ID_OFFSET + TRACE_ID_HEX_SIZE + TRACEPARENT_DELIMITER_SIZE

  private val TRACE_OPTION_OFFSET =
    SPAN_ID_OFFSET + SPAN_ID_HEX_SIZE + TRACEPARENT_DELIMITER_SIZE

  private val TRACEPARENT_HEADER_SIZE =
    TRACE_OPTION_OFFSET + TRACE_OPTION_HEX_SIZE

  private val TRACESTATE_MAX_SIZE = 512

  private val TRACESTATE_MAX_MEMBERS = 32

  private val TRACESTATE_KEY_VALUE_DELIMITER = '='

  private val TRACESTATE_ENTRY_DELIMITER = ','

  private val TRACESTATE_ENTRY_DELIMITER_SPLIT_PATTERN =
    Pattern.compile("[ \t]*" + TRACESTATE_ENTRY_DELIMITER + "[ \t]*")

  private def stringFromTraceParent(traceParent: SpanContext) = Try {
    val chars = TemporaryBuffers.chars(TRACEPARENT_HEADER_SIZE)

    chars.update(0, VERSION.charAt(0))
    chars.update(1, VERSION.charAt(1))
    chars.update(2, TRACEPARENT_DELIMITER)

    val traceId = traceParent.getTraceId

    traceId.toCharArray.zipWithIndex.foreach { case (c, i) =>
      chars.update(TRACE_ID_OFFSET + i, c)
    }

    chars.update(SPAN_ID_OFFSET - 1, TRACEPARENT_DELIMITER)

    val spanId = traceParent.getSpanId

    spanId.toCharArray.zipWithIndex.foreach { case (c, i) =>
      chars.update(SPAN_ID_OFFSET + i, c)
    }

    chars.update(TRACE_OPTION_OFFSET - 1, TRACEPARENT_DELIMITER)

    val traceFlagsHex = traceParent.getTraceFlags.asHex()
    chars.update(TRACE_OPTION_OFFSET, traceFlagsHex.charAt(0))
    chars.update(TRACE_OPTION_OFFSET + 1, traceFlagsHex.charAt(1))

    new String(chars, 0, TRACEPARENT_HEADER_SIZE)
  } match {
    case Success(v) =>
      v

    case Failure(ex) =>
      println(s"Error: $ex")

      ""
  }

  private def stringFromTraceState(traceState: TraceState) = Try {
    val stringBuilder = traceState
      .asMap()
      .asScala
      .foldLeft(new StringBuilder(TRACESTATE_MAX_SIZE)) {
        case (acc, (key, value)) =>
          if (acc.nonEmpty)
            acc.apply(TRACESTATE_ENTRY_DELIMITER)

          acc
            .append(key)
            .append(TRACESTATE_KEY_VALUE_DELIMITER)
            .append(value)
      }

    stringBuilder.toString()
  } match {
    case Success(v) =>
      v

    case Failure(ex) =>
      println(s"Error: $ex")

      ""
  }

  private def traceParentFromString(traceParentHeader: String) =
    Try {
      if (
        !((traceParentHeader.length == TRACEPARENT_HEADER_SIZE ||
          traceParentHeader.length > TRACEPARENT_HEADER_SIZE &&
          traceParentHeader
            .charAt(TRACEPARENT_HEADER_SIZE) == TRACEPARENT_DELIMITER) &&
          traceParentHeader.charAt(
            TRACE_ID_OFFSET - 1
          ) == TRACEPARENT_DELIMITER &&
          traceParentHeader.charAt(
            SPAN_ID_OFFSET - 1
          ) == TRACEPARENT_DELIMITER &&
          traceParentHeader.charAt(
            TRACE_OPTION_OFFSET - 1
          ) == TRACEPARENT_DELIMITER)
      )
        throw new IllegalArgumentException("Invalid trace parent header.")
      else {
        val version = traceParentHeader.substring(0, VERSION_SIZE)

        if (version != VERSION)
          throw new IllegalArgumentException("Invalid trace version.")
        else {
          val traceIdHex = traceParentHeader.substring(
            TRACE_ID_OFFSET,
            TRACE_ID_OFFSET + TRACE_ID_HEX_SIZE
          )

          val spanIdHex = traceParentHeader.substring(
            SPAN_ID_OFFSET,
            SPAN_ID_OFFSET + SPAN_ID_HEX_SIZE
          )

          val firstTraceFlagsChar =
            traceParentHeader.charAt(TRACE_OPTION_OFFSET)

          val secondTraceFlagsChar =
            traceParentHeader.charAt(TRACE_OPTION_OFFSET + 1)

          if (
            !OtelEncodingUtils.isValidBase16Character(firstTraceFlagsChar)
            || !OtelEncodingUtils.isValidBase16Character(secondTraceFlagsChar)
          )
            throw new IllegalArgumentException("Invalid trace flags.")
          else {
            val traceFlags = TraceFlags.fromByte(
              OtelEncodingUtils
                .byteFromBase16(firstTraceFlagsChar, secondTraceFlagsChar)
            )

            SpanContext
              .createFromRemoteParent(
                traceIdHex,
                spanIdHex,
                traceFlags,
                TraceState.getDefault
              )
          }
        }
      }
    } match {
      case Success(v) =>
        v.some

      case Failure(ex) =>
        println(s"Error: $ex")

        none[SpanContext]
    }

  private def traceStateFromString(traceStateHeader: String) = Try {
    val listMembers =
      TRACESTATE_ENTRY_DELIMITER_SPLIT_PATTERN.split(traceStateHeader)

    checkArgument(
      listMembers.length <= TRACESTATE_MAX_MEMBERS,
      "TraceState has too many elements."
    )

    val traceStateBuilder = listMembers.reverse.foldLeft(TraceState.builder()) {
      case (acc, v) =>
        val index = v.indexOf(TRACESTATE_KEY_VALUE_DELIMITER)

        checkArgument(index != -1, "Invalid TraceState list-member format.")

        acc.put(v.substring(0, index), v.substring(index + 1))
    }

    val traceState = traceStateBuilder.build()

    if (traceState.size() != listMembers.length)
      throw new IllegalArgumentException("Invalid trace state size.")
    else
      traceState.some
  } match {
    case Success(v) =>
      v

    case Failure(ex) =>
      println(s"Error: $ex")

      none[TraceState]
  }

  /** Inject
    *
    * @param carrier
    *   carrier
    * @param tracer
    *   tracer
    * @param setter
    *   setter
    * @tparam T
    *   type of carrier
    */
  def inject[T](
    carrier: T,
    tracer: OpenTelemetryTracer
  )(implicit setter: W3CTraceContextSetter[T]): T = {
    val spanContext = tracer.getSpanContext

    val traceParentSetCarrier =
      if (!spanContext.isValid)
        carrier
      else {
        val traceParentHeader = stringFromTraceParent(spanContext)

        setter
          .set(carrier, TRACE_PARENT, traceParentHeader)
      }

    val traceState = spanContext.getTraceState

    if (traceState.isEmpty)
      traceParentSetCarrier
    else {
      val traceStateHeader = stringFromTraceState(traceState)

      setter
        .set(traceParentSetCarrier, TRACE_STATE, traceStateHeader)
    }
  }

  /** Extract
    *
    * @param carrier
    *   carrier
    * @param getter
    *   getter
    * @tparam T
    *   type of carrier
    * @return
    *   context
    */
  def extract[T](
    carrier: T
  )(implicit getter: W3CTraceContextGetter[T]): Context = {
    val maybeTraceParent = for {
      traceParentHeader <- if (getter.get(carrier, TRACE_PARENT).isEmpty) none[String] else getter.get(carrier, TRACE_PARENT)
      traceParent       <- traceParentFromString(traceParentHeader)
    } yield traceParent

    val maybeSpanContext = maybeTraceParent.map { traceParent =>
      val maybeTraceState = for {
        traceStateHeader <- if (getter.get(carrier, TRACE_STATE).isEmpty) none[String] else getter.get(carrier, TRACE_STATE)
        traceState       <- traceStateFromString(traceStateHeader)
      } yield traceState

      maybeTraceState match {
        case Some(v) =>
          SpanContext.createFromRemoteParent(
            traceParent.getTraceId,
            traceParent.getSpanId,
            traceParent.getTraceFlags,
            v
          )

        case None =>
          SpanContext.createFromRemoteParent(
            traceParent.getTraceId,
            traceParent.getSpanId,
            traceParent.getTraceFlags,
            TraceState.getDefault
          )
      }
    }

    maybeSpanContext match {
      case Some(v) =>
        Context.current().`with`(Span.wrap(v))

      case None =>
        Context.current()
    }
  }
}
/** Setter */
trait W3CTraceContextSetter[T] {

  /** Set
    *
    * @param carrier
    *   carrier
    * @param key
    *   key
    * @param value
    *   value
    * @return
    *   carrier
    */
  def set(carrier: T, key: String, value: String): T
}

/** Getter */
trait W3CTraceContextGetter[T] {

  /** Get
    *
    * @param carrier
    *   carrier
    * @param key
    *   key
    * @return
    *   value of string
    */
  def get(carrier: T, key: String): String
}
```
:::

ã‚„ã£ã¦ã„ã‚‹ã“ã¨ã¯æ„šç›´ã«charã‚’è©°ã‚è¾¼ã‚“ã ã‚Šã€ãã®é€†ã‚’ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚

`setter`ã¨`getter`ã‚’`implicit`ã«ã—ã¦ã¾ã™ãŒã€ã“ã®è¾ºã¯å¥½ã¿ã®å•é¡Œã§ç‰¹ã«æ·±ã„ç†ç”±ã¯ç„¡ã„ã§ã™ã€‚

## Akka gRPCã§åˆ©ç”¨ã™ã‚‹
å‡ºæ¥ä¸ŠãŒã£ãŸãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚¿ãƒ¼ã‚’Akka gRPCã«çµ„ã¿è¾¼ã‚“ã§ã¿ã¾ã™ã€‚

ä½¿ç”¨ã™ã‚‹protocolã¯[ã“ã¡ã‚‰](https://github.com/grpc/grpc-java/blob/master/examples/src/main/proto/helloworld.proto)ã€‚

ã¨ã‚Šã‚ãˆãšã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®é–‹å§‹çµ‚äº†ã®ç®¡ç†ã«`scala.util.Using`ã‚’ä½¿ãŠã†ã¨æ€ã†ã®ã§ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ç”¨æ„ã—ã¾ã™ã€‚

```scala
package com.example

import akka.grpc.scaladsl.Metadata
import io.opentelemetry.api.GlobalOpenTelemetry
import io.opentelemetry.api.trace.Span
import io.opentelemetry.api.trace.SpanKind
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.context.Context
import io.opentelemetry.context.Scope

class ContextManager(spanName: String, spanKind: SpanKind, context: Context = Context.root()): AutoCloeable {
  val tracer: Tracer = GlobalOpenTelemetry.getTracer("com.example")
  
  val span: Span = tracer
    .spanBuilder(spanName)
    .setSpanKind(spanKind)
    .setParent(context)
    .startSpan()
    
  val scope: Scope = span.makeCurrent()
  
  override def close(): Unit = {
    scope.close()
    span.end()
  }
}
```

å˜ç´”ã«è¦ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰`Span`ã¨`Scope`ã‚’ç”Ÿæˆã—ã€æœ€çµ‚çš„ã«`close`ã—ã¾ã™ã€‚è¦ªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæŒ‡å®šã•ã‚Œãªã‘ã‚Œã°ãƒ«ãƒ¼ãƒˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒè¦ªã¨ãªã‚Šã¾ã™ã€‚

ã¾ãšã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã€‚

```scala
package com.example

// importã¯çœç•¥

class GreeterServiceImpl(implicit system: ActorSystem) extends GreeterServicePowerApi {
  import system.dispatcher

  implicit val metaDataW3CTraceContextGetter: W3CTraceContextGetter[Metadata] =
    (carrier: Metadata, key: String) => carrier.getText(key).getOrElse("")
  
  override def sayHello(in: HelloRequest, metadata: Metadata): Future[HelloReply] = {
    Future.fromTry {
      Using(new ContextManager("SayHello", SpanKind.SERVER, W3CTraceContextPropergator.extract(metadata)) { _ =>
        HelloReply(s"Hello, ${in.name}")
      }
    }
  }
}
```

ã‚µãƒ¼ãƒãƒ¼å´ã¯Metadataã¸ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã€é€šå¸¸ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã•ã‚ŒãŸã‚µãƒ¼ãƒ“ã‚¹ã§ã¯Metadataã¸ã®ã‚¢ã‚¯ã‚»ã‚¹æ–¹æ³•ãŒç„¡ãã€sbtã«`akkaGrpcCodeGeneratorSettings += "server_power_apis"`ã¨ã„ã†ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¨­å®šã—ã€æœ«å°¾ã«PowerApiã¨ã¤ã„ãŸã‚µãƒ¼ãƒ“ã‚¹ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã‚µãƒ¼ãƒãƒ¼ã‚’Akka Httpã«ä¹—ã›ãŸã‚Šã™ã‚‹éƒ¨åˆ†ã¯å‰²æ„›ã™ã‚‹ã®ã§[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://doc.akka.io/docs/akka-grpc/current/server/walkthrough.html)ç­‰ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„ã€‚

ç¶šã„ã¦ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€‚

```scala
package com.example

// importã¯çœç•¥

object Main extends App {
  implicit def singleResponseRequestBuilderW3CTraceContextSetter[Req, Res]
    : W3CTraceContextSetter[SingleResponseRequestBuilder[Req, Res]] =
    (
      carrier: SingleResponseRequestBuilder[Req, Res],
      key: String,
      value: String
    ) => carrier.addHeader(key, value)

  implicit val sys = ActorSystem("HelloWorldClient")
  implicit val ec = sys.dispatcher
  
  val clientSettings = GrpcClientSettings.connectToServiceAt("127.0.0.1", 8080).withTls(false)
  
  val client: GreeterService = GreeterServiceClient(clientSettings)
  
  Using(new ContextManager("call SayHello", SpanKind.CLIENT) {ctx =>
    W3CTraceContextPropergator
      .inject(client.SayHello(), ctx.tracer)
      .invoke(HelloRequest("Alice"))
      .onComplete {
        case Success(msg) =>
	  msg
	  
	case Failure(e) =>
	  throw e
      }
  }.onComplete {
    case Success(msg) =>
      println(msg)
      
    case Failure(e) =>
      println(s"Error: $e")
  }
}
```

Usingã®æˆ»ã‚Šå€¤ãŒ`Try`ã«å›ºå®šã•ã‚Œã¦ã„ã‚‹ã®ã§åŠ©é•·ã«ãªã£ã¦ã„ã‚‹ã®ã¯å‹˜å¼ã—ã¦ãã ã•ã„ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã¯å¼•æ•°ç„¡ã—ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶ã“ã¨ã§`SingleResponseRequestBuilder`ã‚’æŠ½å‡ºã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ˆ[å‚è€ƒ](https://doc.akka.io/docs/akka-grpc/current/client/details.html)ï¼‰ã€‚

## æ¤œè¨¼ç”»é¢
ã”ã‚ã‚“ãªã•ã„ã€‚ãƒ†ã‚¹ãƒˆç’°å¢ƒã¾ã§ç”¨æ„ã™ã‚‹ã®ãŒã—ã‚“ã©ãã¦æ¤œè¨¼ç”»é¢ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

è©¦ã—ãŸã‹ã£ãŸã‚‰å„è‡ªè©¦ã—ã¦ã¿ã¦ã­ï¼ˆç„¡è²¬ä»»ï¼‰ã€‚

# çµ‚ã‚ã‚Šã«
## æœ¬å½“ã¯ãƒ»ãƒ»ãƒ»
æœ¬å½“ã¯Catsã®Resoureã‚’ä½¿ã£ãŸã‚Šã—ã¦ã‚‚ã£ã¨æµã‚Œã‚‹ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æç¤ºã—ãŸã„ã®ã§ã™ãŒã€ã‚³ãƒ¼ãƒ‰ã‚„è§£èª¬ãŒè¼ªã‚’ã‹ã‘ã¦é•·ã£ãŸã‚‰ã—ããªã‚‹ã®ã§è¾ã‚ã¦ãŠãã¾ã—ãŸã€‚

## ã¾ã¨ã‚
- ãŸã ãƒˆãƒ¬ãƒ¼ã‚¹ã™ã‚‹ã ã‘ãªã‚‰CloudTraceã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆé€šã‚Šã§ç°¡å˜ã«å®Ÿè£…å¯èƒ½ã€‚
- åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã«ã¯ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä¼æ¬ãŒå¿…è¦ã€‚
- ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚¿ãƒ¼ã®å‰¯ä½œç”¨ãŒå«Œã ã£ãŸã‹ã‚‰è‡ªä½œã€‚
- Akka gRPCã«ã¯Interceptorã¯ç„¡ã„ã‹ã‚‰åº¦ã€…ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®å­ã‚¹ãƒ‘ãƒ³ã‚’ä½œã£ã¦ä¼æ¬ã—ã¦ã­ã€‚